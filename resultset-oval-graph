#!/usr/bin/perl -w

use strict;
use JSON;
use POSIX;
use IPC::Open2;

# List datalink runs in a tar archive
sub list_runs ($) {
  my ( $dirname ) = @_;

  opendir( my $handle, $dirname ) or die qq{$dirname: $!};
  my @ret = grep { m{_datalink_run\d+\.log$} } readdir( $handle );
  closedir $handle or die qq{$!};

  return @ret;
}

sub get_file ($$) {
  my ( $dirname, $inner_filename ) = @_;

  $inner_filename = ($dirname) . q{/} . $inner_filename;

  local $/; # so subsequent <> reads the whole file
  open( my $handle, q{<}, $inner_filename ) or die qq{$inner_filename: $!};
  my $contents = <$handle>;
  close $handle or die qq{$!};

  return $contents;
}

sub get_metadata ($) {
  my ( $dirname ) = @_;
  my $contents = get_file( $dirname, q{pantheon_metadata.json} );

  my $doc = decode_json $contents;

  if ( not defined $doc->{ local_information } ) {
    die qq{Invalid pantheon.json: $contents};
  }

  return $doc;
}

# Parse arguments
if ( scalar @ARGV != 1 ) {
  die qq{Usage: $0 DIRNAME\n};
}

my ( $dirname ) = @ARGV;

print STDERR qq{Analyzing $dirname.\n};

# List the datalink runs
my @runs = list_runs $dirname;

# Count the schemes, and runs per scheme
my %schemes;
for ( @runs ) {
  my ( $scheme, $run_number ) = m{^(.*?)_datalink_run(\d+)\.log$};
  if ( not defined $scheme or not defined $run_number ) {
    die qq{Could not parse run filename: $_};
  }

  $schemes{ $scheme }{ $run_number } = $_;
}

print STDERR q{Found } . (scalar @runs ) . qq{ runs in total.\n};
print STDERR q{Found } . (scalar keys %schemes) . q{ schemes: }
  . (join q{ }, map { qq{$_ (} . (scalar keys %{ $schemes{ $_ } }) . q{)} } keys %schemes )
  . qq{.\n};

# omit some schemes from analysis
delete $schemes{ greg_saturator };
delete $schemes{ saturator };

# Fetch metadata
my $metadata = get_metadata $dirname;

my ( $sender, $receiver );
if ( $metadata->{ sender_side } eq q{local} ) {
  my $sender_interface = (defined $metadata->{ local_interface })
    ? qq{ ($metadata->{ local_interface })} : q{};
  my $receiver_interface = (defined $metadata->{ remote_interface })
    ? qq{ ($metadata->{ remote_interface })} : q{};
  $sender = qq{$metadata->{ local_information }$sender_interface};
  $receiver = qq{$metadata->{ remote_information }$receiver_interface};
} else {
  my $sender_interface = (defined $metadata->{ remote_interface })
    ? qq{ ($metadata->{ remote_interface })} : q{};
  my $receiver_interface = (defined $metadata->{ local_interface })
    ? qq{ ($metadata->{ local_interface })} : q{};
  $sender = qq{$metadata->{ remote_information }$sender_interface};
  $receiver = qq{$metadata->{ local_information }$receiver_interface};
}

print STDERR qq{Experiment was from $sender => $receiver for $metadata->{ runtime } seconds.\n};

sub quantile ($@) {
  my ( $quantile, @array ) = @_;
  @array = sort { $a <=> $b } @array;
  my $index_low = floor( $#array * $quantile );
  my $index_high = ceil( $#array * $quantile );
  return ( $array[ $index_low ] + $array[ $index_high ] ) / 2.0;
}

sub analyze ($) {
  my ( $contents ) = @_;
  my @lines = split m{\n}s, $contents;
  my @timestamps;
  my $total_delivery_bytes = 0;
  my @delays;

 EVENT: for ( @lines ) {
    next EVENT if m{^#};
    my @fields = split m{\s+}, $_;
    my $direction = $fields[ 1 ];
    if ( not defined $direction or ($direction ne q{+} and $direction ne q{-}) ) {
      die qq{Invalid data-link line: $_};
    }

    next EVENT if $direction eq q{+}; # ingress, ignore

    my ( $timestamp, $size, $delay ) = @fields[ 0, 2, 3 ];
    push @timestamps, $timestamp;
    $total_delivery_bytes += $size;
    push @delays, $delay;
  }

  # confirm expected duration
  if ( scalar @timestamps == 0 ) {
    print STDERR qq{(empty) };
    return ( -1, -1 );
  }

  my $duration = ($timestamps[ -1 ] - $timestamps[ 0 ]) / 1000.0;
  my $expected_duration = $metadata->{ runtime };
  if ( $duration < $expected_duration * .9 ) {
    printf STDERR q{(short duration %.0f%%) }, 100 * $duration / $expected_duration;
    return ( -1, -1 );
  } elsif ( $duration > $expected_duration * 1.1 ) {
    printf STDERR q{(long duration %.0f%%) }, 100 * $duration / $expected_duration;
    return ( -1, -1 );
  }

  # calculate throughput and delay
  my $throughput = $total_delivery_bytes / $duration;
  my $p95delay = quantile( .95, @delays );

  return ( $throughput, $p95delay );
}

my @all_points;
my %statistics;
my %median;
for my $scheme ( sort keys %schemes ) {
  print STDERR qq{Analyzing $scheme... [ };

  RUN: for my $run_number ( sort { $a <=> $b } keys %{ $schemes{ $scheme } } ) {
    print STDERR qq{$run_number };
    my $log = get_file( $dirname, $schemes{ $scheme }->{ $run_number } );
    my ( $throughput, $p95delay ) = analyze $log;
    if ( $throughput < 0 ) { # rejected run
      next RUN;
    }

    my $point = { throughput => 8 * 1.e-6 * $throughput, p95delay => $p95delay };
    push @{ $statistics{ $scheme } }, $point;
    push @all_points, $point;
  }

  printf STDERR q{] done (%d/%d used)},
    scalar @{ $statistics{ $scheme } },
    scalar ( keys %{ $schemes{ $scheme } } );

  $median{ $scheme }{ throughput } = quantile( 0.5, map { $_->{ throughput } } @{ $statistics{ $scheme } } );
  $median{ $scheme }{ delay } = quantile( 0.5, map { $_->{ p95delay } } @{ $statistics{ $scheme } } );

  printf STDERR qq{ (median throughput: %.3f Mbit/s, p95delay: %.0f ms)\n},
    $median{ $scheme }{ throughput }, $median{ $scheme }{ delay };
}

my $minimum_throughput = quantile( 0.0, map { $_->{ throughput } } @all_points );
my $maximum_throughput = quantile( 1.0, map { $_->{ throughput } } @all_points );
my $minimum_delay = quantile( 0.0, map { $_->{ p95delay } } @all_points );
my $maximum_delay = quantile( 1.0, map { $_->{ p95delay } } @all_points );

# expand graph
my $display_minimum_throughput = $minimum_throughput - 0.1 * ($maximum_throughput - $minimum_throughput);
$display_minimum_throughput = 0 if $display_minimum_throughput < 0;
my $display_maximum_throughput = $maximum_throughput + 0.1 * ($maximum_throughput - $minimum_throughput);
my $display_minimum_delay = 0.8 * $minimum_delay;
my $display_maximum_delay = 1.25 * $maximum_delay;

my $gnuplot_pid = open2( my $gnuplot_reader, my $gnuplot_writer, q{gnuplot} ) or die qq{gnuplot: $!};

print $gnuplot_writer <<"END";
set xlabel "delay (95th percentile ms)"
set ylabel "throughput (Mbits/s)"
set terminal svg size 1024,768 fsize 20 rounded solid
set logscale x
unset key
set xrange [$display_maximum_delay:$display_minimum_delay] reverse
set yrange [$display_minimum_throughput:$display_maximum_throughput]
set xtics 2
END

my %display_name = ( copa => q{Copa}, default_tcp => q{TCP Cubic}, greg_saturator => q{GHsat},
		     koho_cc => q{Koho}, ledbat => q{LEDBAT}, pcc => q{PCC},
		     quic => q{QUIC Cubic}, saturator => q{YYsat},
		     scream => q{SCReAM}, sprout => q{Sprout},
		     vegas => q{Vegas}, verus => q{Verus}, webrtc => q{WebRTC} );

# print labels
for my $scheme ( sort keys %median ) {
  print $gnuplot_writer qq{set label "$display_name{ $scheme }" at $median{ $scheme }{ delay }, $median{ $scheme }{ throughput } center offset -1, 1\n};
}

# print open circles for each median
print $gnuplot_writer qq{plot "-" using 1:2 lt 6 ps 2.0 lc rgb "#000000ff"\n};
for my $scheme ( sort keys %median ) {
  print $gnuplot_writer qq{$median{ $scheme }{ delay } $median{ $scheme }{ throughput }\n};
}

close $gnuplot_writer or die qq{$!};

while ( <$gnuplot_reader> ) {
  print;
}

close $gnuplot_reader or die qq{$!};

waitpid( $gnuplot_pid, 0 );
